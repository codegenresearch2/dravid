import traceback\\nfrom ...api.main import call_dravid_api\\nfrom ...utils.step_executor import Executor\\nfrom ...utils.utils import print_error, print_success, print_info, print_command_details\\nfrom ...utils.loader import run_with_loader\\nfrom ...prompts.monitor_error_resolution import get_error_resolution_prompt\\nfrom ..query.file_operations import get_files_to_modify\\nfrom ...utils.file_utils import get_file_content\\n\\n\\ndef monitoring_handle_error_with_dravid(error, line, monitor):\\n    print_error(f"Error detected: {error}")\\n\\n    error_message = str(error)\\n    error_type = type(error).__name__\\n    error_trace = ''.join(traceback.format_exception(type(error), error, error.__traceback__))\\n\\n    project_context = monitor.metadata_manager.get_project_context()\\n\\n    print_info("Identifying relevant files for error context...")\\n    error_details = f"error_msg: {error_message}, error_type: {error_type}, error_trace: {error_trace}"\\n    files_to_check = run_with_loader(\\n        lambda: get_files_to_modify(error_details, project_context),\\n        "Analyzing project files"\\n    )\\n\\n    print_info(f"Found {len(files_to_check)} potentially relevant files.")\\n\\n    file_contents = {}\\n    for file in files_to_check:\\n        content = get_file_content(file)\\n        if content:\\n            file_contents[file] = content\\n            print_info(f"  - Read content of {file}")\\n\\n    file_context = "\\n".join([f"Content of {file}:\\n{content}" for file, content in file_contents.items()])\\n\\n    error_query = get_error_resolution_prompt(\\n        error_type, error_message, error_trace, line, project_context, file_context\\n    )\\n\\n    print_info("Sending error information to Dravid for analysis...")\\n    try:\\n        commands = call_dravid_api(error_query, include_context=True)\\n    except ValueError as e:\\n        print_error(f"Error parsing dravid's response: {str(e)}")\\n        return False\\n\\n    requires_restart = False\\n    fix_commands = []\\n    for command in commands:\\n        if command['type'] == 'requires_restart':\\n            requires_restart = command['content'].lower() == 'true'\\n        elif command['type'] != 'explanation':\\n            fix_commands.append(command)\\n\\n    print_info("Dravid's suggested fix:")\\n    print_command_details(fix_commands)\\n\\n    user_input = monitor.get_user_input(\\n        "üöÄ Do you want to proceed with this fix? You will be able to stop anytime during the step. [y/N]: "\\n    )\\n\\n    if user_input.lower() == 'y':\\n        print_info("Applying dravid's suggested fix...")\\n        executor = Executor()\\n        for cmd in fix_commands:\\n            if cmd['type'] == 'shell':\\n                print_info(f"Executing: {cmd['command']}")\\n                executor.execute_shell_command(cmd['command'])\\n            elif cmd['type'] == 'file':\\n                print_info(f"Performing file operation: {cmd['operation']} on {cmd['filename']}")\\n                executor.perform_file_operation(\\n                    cmd['operation'], cmd['filename'], cmd.get('content')\\n                )\\n\\n        print_success("Fix applied.")\\n\\n        if requires_restart:\\n            print_info("The applied fix requires a server restart.")\\n            restart_input = monitor.get_user_input(\\n                "üåê Do you want to restart the server now? [y/N]: "\\n            )\\n            if restart_input.lower() == 'y':\\n                print_info("Requesting server restart...")\\n                monitor.request_restart()\\n            else:\\n                print_info("Server restart postponed. You may need to restart manually if issues persist.")\\n        else:\\n            print_info("The applied fix does not require a server restart.")\\n\\n        return True\\n    else:\\n        print_info("Fix not applied. Continuing with current state.")\\n        return False