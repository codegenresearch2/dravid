import os\"nimport traceback\nfrom ...api.main import call_dravid_api\nfrom ...utils.step_executor import Executor\nfrom ...utils.utils import print_error, print_success, print_info, print_prompt\nfrom ...utils.loader import run_with_loader\nfrom ...prompts.monitor_error_resolution import get_error_resolution_prompt\nfrom ..query.file_operations import get_files_to_modify\nfrom ...utils.file_utils import get_file_content\nfrom ...utils.input import confirm_with_user\n\n\ndef monitoring_handle_error_with_dravid(error, line, monitor):\n    print_error(f"Error detected: {error}")\n\n    error_message = str(error)\n    error_type = type(error).__name__\n    error_trace = ''.join(traceback.format_exception(type(error), error, error.__traceback__))\n\n    project_context = monitor.metadata_manager.get_project_context()\n\n    print_info("Identifying relevant files for error context...")\n    error_details = f"error_msg: {error_message}, error_type: {error_type}, error_trace: {error_trace}"\n    files_to_check = run_with_loader(\n        lambda: get_files_to_modify(error_details, project_context),\n        "Analyzing project files"\n    )\n\n    print_info(f"Found {len(files_to_check)} potentially relevant files.")\n\n    file_contents = {}\\n    for file in files_to_check:\n        content = get_file_content(file)\n        if content:\n            file_contents[file] = content\n            print_info(f"  - Read content of {file}")\n\n    file_context = "\n".join(\n        [f"Content of {file}:\n{content}" for file, content in file_contents.items()]\n    )\n\n    error_query = get_error_resolution_prompt(\n        error_type, error_message, error_trace, line, project_context, file_context\n    )\n\n    print_info("üîç Sending error information to Dravid for analysis...")\n    try:\n        commands = call_dravid_api(error_query, include_context=True)\n    except ValueError as e:\n        print_error(f"Error parsing dravid's response: {str(e)}")\n        return False\n\n    requires_restart = False\n    fix_commands = []\n    for command in commands:\n        if command['type'] == 'requires_restart':\n            requires_restart = command['content'].lower() == 'true'\n        elif command['type'] != 'explanation':\n            fix_commands.append(command)\n\n    print_prompt("Dravid's suggested fix...")\n    executor = Executor()\n    for cmd in fix_commands:\n        if cmd['type'] == 'shell':\n            executor.execute_shell_command(cmd['command'])\n        elif cmd['type'] == 'explanation':\n            print_info(cmd.get('content'))\n        elif cmd['type'] == 'file':\n            executor.perform_file_operation(\n                cmd['operation'], cmd['filename'], cmd.get('content')\n            )\n\n    print_success("Fix applied.")\n\n    if requires_restart:\n        print_info("The applied fix requires a server restart.")\n        restart_input = confirm_with_user(\n            "Do you want to restart the server now? [y/N]: "\n        )\n        if restart_input:\n            print_info("Requesting server restart...")\n            monitor.request_restart()\n        else:\n            print_info(\n                "Server restart postponed. You may need to restart manually if issues persist."\n            )\n    else:\n        print_info("The applied fix does not require a server restart.")\n\n    return True