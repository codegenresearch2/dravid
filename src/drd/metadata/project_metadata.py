import os\"nimport json\"nfrom datetime import datetime\"nimport fnmatch\"nimport xml.etree.ElementTree as ET\"nimport mimetypes\"n\"nclass ProjectMetadataManager:\"n    def __init__(self, project_dir):\"n        self.project_dir = os.path.abspath(project_dir)\"n        self.metadata_file = os.path.join(self.project_dir, 'drd.json')\"n        self.metadata = self.load_metadata()\"n        self.ignore_patterns = self.get_ignore_patterns()\"n        self.binary_extensions = {'.pyc', '.pyo', '.so', '.dll', '.exe', '.bin'}\"n        self.image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.ico'}\"n\"n    def load_metadata(self):\"n        if os.path.exists(self.metadata_file):\"n            with open(self.metadata_file, 'r') as f:\"n                return json.load(f)\"n        new_metadata = {\"project_info": {\"name": os.path.basename(self.project_dir), \"version\": "1.0.0", \"description\": "", \"last_updated\": datetime.now().isoformat()}\"n            \"environment\": {\"primary_language\": "", \"other_languages\": [], \"primary_framework\": "", \"runtime_version\": ""}\"n            \"directory_structure\": {}, \"key_files\": [], \"external_dependencies\": [], \"dev_server\": {\"start_command\": ""}\"n        return new_metadata\"n\"n    def save_metadata(self):\"n        with open(self.metadata_file, 'w') as f:\"n            json.dump(self.metadata, f, indent=2)\"n\"n    def get_ignore_patterns(self):\"n        patterns = [\"**/.git/**", "**/node_modules/**", "**/dist/**", "**/build/**", "**/__pycache__/**", "**/.venv/**", "**/.idea/**", "**/.vscode/**"]\"n        for root, _, files in os.walk(self.project_dir):\"n            if '.gitignore' in files:\"n                gitignore_path = os.path.join(root, '.gitignore')\"n                rel_root = os.path.relpath(root, self.project_dir)\"n                with open(gitignore_path, 'r') as f:\"n                    for line in f:\"n                        line = line.strip()\"n                        if line and not line.startswith('#'):\"n                            if rel_root == '.':\"n                                patterns.append(line)\"n                            else:\"n                                patterns.append(os.path.join(rel_root, line))\"n        return patterns\"n\"n    def should_ignore(self, path):\"n        try:\"n            path_str = str(path)\"n            abs_path = os.path.abspath(path_str)\"n            rel_path = os.path.relpath(abs_path, self.project_dir)\"n            if rel_path.startswith('..'):\"n                return True\"n            for pattern in self.ignore_patterns:\"n                if pattern.endswith('/'):\"n                    if rel_path.startswith(pattern) or rel_path.startswith(pattern[:-1]):\"n                        return True\"n                elif fnmatch.fnmatch(rel_path, pattern):\"n                    return True\"n            return False\"n        except Exception as e:\"n            print_warning(f"Error in should_ignore for path {path}: {str(e)}")\"n            return True\"n\"n    # Additional methods for directory structure, binary file detection, and other functionalities would follow here...\"n