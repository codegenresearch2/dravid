import os\"import json\", \"from datetime import datetime\", \"import fnmatch\", \"import xml.etree.ElementTree as ET\", \"import mimetypes\", \"from ..prompts.file_metada_desc_prompts import get_file_metadata_prompt\", \"from ..api import call_dravid_api_with_pagination\", \"from ..utils.utils import print_info, print_warning\", \"from .common_utils import get_ignore_patterns, get_folder_structure, find_file_with_dravid\", \"from ..prompts.metadata_update_prompts import get_files_to_update_prompt\", \"import asyncio\"\", \"class ProjectMetadataManager:\", \"    def __init__(self, project_dir):\", \"        self.project_dir = os.path.abspath(project_dir)\", \"        self.metadata_file = os.path.join(self.project_dir, 'drd.json')\", \"        self.metadata = self.load_metadata()\", \"        self.ignore_patterns = self.get_ignore_patterns()\", \"        self.binary_extensions = {'.pyc', '.pyo', '.so', '.dll', '.exe', '.bin'}\", \"        self.image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.ico'}\", \"    def load_metadata(self):\", \"        if os.path.exists(self.metadata_file):\", \"            with open(self.metadata_file, 'r') as f:\", \"                return json.load(f)\", \"        new_metadata = {\", \"            'project_info': {\", \"                'name':  os.path.basename(self.project_dir),\", \"                'version': '1.0.0',\", \"                'description': '',\", \"                'last_updated': datetime.now().isoformat()\", \"            },\", \"            'environment': {\", \"                'primary_language': '',\", \"                'other_languages': [],\", \"                'primary_framework': '',\", \"                'runtime_version': ''\", \"            },\", \"            'directory_structure': {},\", \"            'key_files': [],\", \"            'external_dependencies': [],\", \"            'dev_server': {\", \"                'start_command': ''\", \"            }\", \"        }\", \"        return new_metadata\", \"    def save_metadata(self):\", \"        with open(self.metadata_file, 'w') as f:\", \"            json.dump(self.metadata, f, indent=2)\", \"    def get_ignore_patterns(self):\", \"        patterns = [\", \"            '**/.git/**', '**/node_modules/**', '**/dist/**', '**/build/**', '**/__pycache__/**', '**/.venv/**', '**/.idea/**', '**/.vscode/**'\", \"        ]\", \"        for root, _, files in os.walk(self.project_dir):\", \"            if '.gitignore' in files:\", \"                gitignore_path = os.path.join(root, '.gitignore')\", \"                rel_root = os.path.relpath(root, self.project_dir)\", \"                with open(gitignore_path, 'r') as f:\", \"                    for line in f:\", \"                        line = line.strip()\", \"                        if line and not line.startswith('#'):\", \"                            if rel_root == '.':\", \"                                patterns.append(line)\", \"                            else:\", \"                                patterns.append(os.path.join(rel_root, line))\", \"        return patterns\", \"    def should_ignore(self, path):\", \"        try:\", \"            path_str = str(path)\", \"            abs_path = os.path.abspath(path_str)\", \"            rel_path = os.path.relpath(abs_path, self.project_dir)\", \"            if rel_path.startswith('..'):\", \"                return True\", \"            for pattern in self.ignore_patterns:\", \"                if pattern.endswith('/'):\", \"                    if rel_path.startswith(pattern) or rel_path.startswith(pattern[:-1]):\", \"                        return True\", \"                elif fnmatch.fnmatch(rel_path, pattern):\", \"                    return True\", \"            return False\", \"        except Exception as e:\", \"            print_warning(f'Error in should_ignore for path {path}: {str(e)}')\", \"            return True\", \"    def get_directory_structure(self, start_path):\", \"        structure = {}\", \"        for root, dirs, files in os.walk(start_path):\", \"            if self.should_ignore(root):\", \"                continue\", \"            path = os.path.relpath(root, start_path)\", \"            if path == '.':\", \"                structure['files'] = [f for f in files if not self.should_ignore(os.path.join(root, f))]\\