import re\\nimport click\\n\\nstate = {'buffer': '', 'in_step': False}\\\\\n\\ndef pretty_print_xml_stream(chunk, state):\\n    state['buffer'] += chunk\\n\\n    max_iterations = 1000\\n    iteration_count = 0\\n\\n    while iteration_count < max_iterations:\\n        iteration_count += 1\\n\\n        if not state.get('in_step'):\\n            # Process explanation tags\\n            match = re.search(r'<\\s*explanation\\s*>.*?<\\s*/\\s*explanation\\s*>', state['buffer'], re.DOTALL | re.IGNORECASE)\\n            if match:\\n                explanation = match.group(0).strip()\\n                click.echo(click.style('\nExplanation:', fg='green', bold=True), nl=False) \\n                click.echo(f' {explanation}')\\n                state['buffer'] = state['buffer'][match.end():] \\n                continue\\n\\n            # Look for step start\\n            step_start = re.search(r'<\\s*step\\s*>', state['buffer'], re.IGNORECASE) \\n            if step_start:\\n                state['in_step'] = True\\n                state['buffer'] = state['buffer'][step_start.end():] \\n                continue\\n\\n        if state['in_step']:\\n            step_end = re.search(r'<\\s*/\\s*step\\s*>', state['buffer'], re.IGNORECASE) \\n            if step_end:\\n                step_content = state['buffer'][:step_end.start()].strip()\\n                state['buffer'] = state['buffer'][step_end.end():] \\n                state['in_step'] = False\\n\\n                # Process step content\\n                type_match = re.search(r'<\\s*type\\s*>.*?<\\s*/\\s*type\\s*>', step_content, re.DOTALL | re.IGNORECASE) \\n                if type_match:\\n                    step_type = type_match.group(0).strip().lower()\\n                    if step_type == 'file':\\n                        operation_match = re.search(r'<\\s*operation\\s*>.*?<\\s*/\\s*operation\\s*>', step_content, re.DOTALL | re.IGNORECASE) \\n                        filename_match = re.search(r'<\\s*filename\\s*>.*?<\\s*/\\s*filename\\s*>', step_content, re.DOTALL | re.IGNORECASE) \\n                        if operation_match and filename_match:\\n                            operation = operation_match.group(0).strip()\\n                            filename = filename_match.group(0).strip()\\n                            click.echo(click.style('\nFile Operation:', fg='yellow', bold=True), nl=False) \\n                            click.echo(f' {operation} {filename}')\\n\\n                            # Process CDATA content\\n                            cdata_start = step_content.find('<![CDATA[')\\n                            if cdata_start != -1:\\n                                cdata_end = step_content.rfind(']]>')\\n                                if cdata_end != -1:\\n                                    cdata_content = step_content[cdata_start+9:cdata_end] \\n                                    click.echo(click.style('\nFile Content:', fg='cyan', bold=True))\\n                                    click.echo(cdata_content) \\n                    elif step_type == 'shell':\\n                        command_match = re.search(r'<\\s*command\\s*>.*?<\\s*/\\s*command\\s*>', step_content, re.DOTALL | re.IGNORECASE) \\n                        if command_match:\\n                            command = command_match.group(0).strip()\\n                            click.echo(click.style('\nShell Command:', fg='blue', bold=True), nl=False) \\n                            click.echo(f' {command}')\\n                continue\\n\\n        # If we've reached this point, we couldn't process anything in this iteration\\n        break\\n\\n    if iteration_count == max_iterations:\\n        print('Debug: Max iterations reached, possible infinite loop detected') \\n\\n    if state['buffer'].strip():\\n        click.echo(f'\nRemaining Content: {state['buffer'].strip()}')\\n\\n    click.echo()  # Final newline