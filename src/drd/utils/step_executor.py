import subprocess
import os
import json
import click
from colorama import Fore, Style
import time
import re
from .utils import print_error, print_success, print_info, print_warning, create_confirmation_box
from .diff import preview_file_changes
from .apply_file_changes import apply_changes
from ..metadata.common_utils import get_ignore_patterns, get_folder_structure


class Executor:
    def __init__(self):
        self.current_dir = os.getcwd()
        self.allowed_directories = [self.current_dir, '/fake/path']

        self.initial_dir = self.current_dir
        self.disallowed_commands = [
            'rmdir', 'del', 'format', 'mkfs',
            'dd', 'fsck', 'mkswap', 'mount', 'umount',
            'sudo', 'su', 'chown', 'chmod'
        ]
        self.env = os.environ.copy()

    def is_safe_path(self, path):
        full_path = os.path.abspath(path)
        return any(full_path.startswith(allowed_dir) for allowed_dir in self.allowed_directories) or full_path == self.current_dir

    def is_safe_rm_command(self, command):
        parts = command.split()
        if parts[0] != 'rm':
            return False

        # Check for dangerous flags
        dangerous_flags = ['-r', '-f', '-rf', '-fr']
        if any(flag in parts for flag in dangerous_flags):
            return False

        # Check if it's removing a specific file\n        if len(parts) != 2:\n            return False\n\n        file_to_remove = parts[1]\n        return self.is_safe_path(file_to_remove) and os.path.isfile(os.path.join(self.current_dir, file_to_remove))\n\n    def is_safe_command(self, command):\n        command_parts = command.split()\n        if command_parts[0] == 'rm':\n            return self.is_safe_rm_command(command)\n        return not any(cmd in self.disallowed_commands for cmd in command_parts)\n\n    def perform_file_operation(self, operation, filename, content=None, force=False):\n        full_path = os.path.abspath(os.path.join(self.current_dir, filename))\n\n        if not self.is_safe_path(full_path):\n            confirmation_box = create_confirmation_box(\n                filename, f"File operation is being carried out outside of the project directory. {operation.lower()} this file")\n            print(confirmation_box)\n            if not click.confirm(f"{Fore.YELLOW}Confirm {operation.lower()} [y/N]:{Style.RESET_ALL}", default=False):\n                print_info(f"File {operation.lower()} cancelled by user.")\n                return "Skipping this step"\n\n        print_info(f"File: {filename}")\n\n        if operation == 'CREATE':\n            if os.path.exists(full_path) and not force:\n                print_info(f"File already exists: {filename}")\n                return False\n            try:\n                os.makedirs(os.path.dirname(full_path), exist_ok=True)\n                preview = preview_file_changes(\n                    operation, filename, new_content=content)\n                print(preview)\n                if click.confirm(f"{Fore.YELLOW}Confirm creation [y/N]:{Style.RESET_ALL}", default=False):\n                    with open(full_path, 'w') as f:\n                        f.write(content)\n                    print_success(f"File created successfully: {filename}")\n                    return True\n                else:\n                    print_info("File creation cancelled by user.")\n                    return "Skipping this step"\n            except Exception as e:\n                print_error(f"Error creating file: {str(e)}")\n                return False\n\n        elif operation == 'UPDATE':\n            if not os.path.exists(full_path):\n                print_info(f"File does not exist: {filename}")\n                return False\n            try:\n                with open(full_path, 'r') as f:\n                    original_content = f.read()\n\n                if content:\n                    updated_content = apply_changes(original_content, content)\n                    preview = preview_file_changes(\n                        operation, filename, new_content=updated_content, original_content=original_content)\n                    print(preview)\n                    confirmation_box = create_confirmation_box(\n                        filename, f"{operation.lower()} this file")\n                    print(confirmation_box)\n\n                    if click.confirm(f"{Fore.YELLOW}Confirm update [y/N]:{Style.RESET_ALL}", default=False):\n                        with open(full_path, 'w') as f:\n                            f.write(updated_content)\n                        print_success(f"File updated successfully: {filename}")\n                        return True\n                    else:\n                        print_info(f"File update cancelled by user.")\n                        return "Skipping this step"\n                else:\n                    print_error(\n                        "No content or changes provided for update operation")\n                    return False\n            except Exception as e:\n                print_error(f"Error updating file: {str(e)}")\n                return False\n\n        elif operation == 'DELETE':\n            if not os.path.isfile(full_path):\n                print_info(\n                    f"Delete operation is only allowed for files: {filename}")\n                return False\n            confirmation_box = create_confirmation_box(\n                filename, f"{operation.lower()} this file")\n            print(confirmation_box)\n            if click.confirm(f"{Fore.YELLOW}Confirm deletion [y/N]:{Style.RESET_ALL}", default=False):\n                try:\n                    os.remove(full_path)\n                    print_success(f"File deleted successfully: {filename}")\n                    return True\n                except Exception as e:\n                    print_error(f"Error deleting file: {str(e)}")\n                    return False\n            else:\n                print_info("File deletion cancelled by user.")\n                return "Skipping this step"\n\n        else:\n            print_error(f"Unknown file operation: {operation}")\n            return False\n\n    def parse_json(self, json_string):\n        try:\n            return json.loads(json_string)\n        except json.JSONDecodeError as e:\n            print_error(f"JSON parsing error: {str(e)}")\n            return None\n\n    def merge_json(self, existing_content, new_content):\n        try:\n            existing_json = json.loads(existing_content)\n            new_json = json.loads(new_content)\n            merged_json = {**existing_json, **new_json}\n            return json.dumps(merged_json, indent=2)\n        except json.JSONDecodeError as e:\n            print_error(f"Error merging JSON content: {str(e)}")\n            return None\n\n    def get_folder_structure(self):\n        ignore_patterns, _ = get_ignore_patterns(self.current_dir)\n        return get_folder_structure(self.current_dir, ignore_patterns)\n\n    def execute_shell_command(self, command, timeout=300):  # 5 minutes timeout\n        if not self.is_safe_command(command):\n            print_warning(f"Please verify the command once: {command}")\n\n        confirmation_box = create_confirmation_box(\n            command, "execute this command")\n        print(confirmation_box)\n\n        if not click.confirm(f"{Fore.YELLOW}Confirm execution [y/N]:{Style.RESET_ALL}", default=False):\n            print_info("Command execution cancelled by user.")\n            return 'Skipping this step...'\n\n        click.echo(\n            f"{Fore.YELLOW}Executing shell command: {command}{Style.RESET_ALL}")\n\n        if command.strip().startswith(('cd', 'chdir')):\n            return self._handle_cd_command(command)\n        elif command.strip().startswith(('source', '.')):\n            return self._handle_source_command(command)\n        else:\n            return self._execute_single_command(command, timeout)\n\n    def _execute_single_command(self, command, timeout):\n        try:\n            process = subprocess.Popen(\n                command,\n                shell=True,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n                env=self.env,\n                cwd=self.current_dir\n            )\n\n            start_time = time.time()\n            output = []\n            while True:\n                return_code = process.poll()\n                if return_code is not None:\n                    break\n                if time.time() - start_time > timeout:\n                    process.terminate()\n                    error_message = f"Command timed out after {timeout} seconds: {command}"\n                    print_error(error_message)\n                    raise Exception(error_message)\n\n                line = process.stdout.readline()\n                if line:\n                    print(line.strip())\n                    output.append(line)\n\n                time.sleep(0.1)\n\n            stdout, stderr = process.communicate()\n            output.append(stdout)\n\n            if return_code != 0:\n                error_message = f"Command failed with return code {return_code}\nError output: {stderr}"\n                print_error(error_message)\n                raise Exception(error_message)\n\n            self._update_env_from_command(command)\n\n            print_success("Command executed successfully.")\n            return ''.join(output)\n\n        except Exception as e:\n            error_message = f"Error executing command '{command}': {str(e)}"\n            print_error(error_message)\n            raise Exception(error_message)\n\n    def _handle_source_command(self, command):\n        # Extract the file path from the source command\n        _, file_path = command.split(None, 1)\n        file_path = os.path.expandvars(os.path.expanduser(file_path))\n\n        if not os.path.isfile(file_path):\n            error_message = f"Source file not found: {file_path}"\n            print_error(error_message)\n            raise Exception(error_message)\n\n        # Execute the source command in a subshell and capture the environment changes\n        try:\n            result = subprocess.run(\n                f'source {file_path} && env',\n                shell=True,\n                check=True,\n                capture_output=True,\n                text=True,\n                executable='/bin/bash'\n            )\n\n            # Update the environment with any changes\n            for line in result.stdout.splitlines():\n                if '=' in line:\n                    key, value = line.split('=', 1)\n                    self.env[key] = value\n\n            print_success(f"Sourced file successfully: {file_path}")\n            return "Source command executed successfully"\n        except subprocess.CalledProcessError as e:\n            error_message = f"Error executing source command: {str(e)}"\n            print_error(error_message)\n            raise Exception(error_message)\n\n    def _update_env_from_command(self, command):\n        if '=' in command:\n            if command.startswith('export '):\n                # Handle export command\n                _, var_assignment = command.split(None, 1)\n                key, value = var_assignment.split('=', 1)\n                self.env[key.strip()] = value.strip().strip('"\'')\n            elif command.startswith('set '):\n                # Handle set command\n                _, var_assignment = command.split(None, 1)\n                key, value = var_assignment.split('=', 1)\n                self.env[key.strip()] = value.strip().strip('"\'')\n            else:\n                # Handle simple assignment\n                key, value = command.split('=', 1)\n                self.env[key.strip()] = value.strip().strip('"\'')\n\n    def _handle_cd_command(self, command):\n        _, path = command.split(None, 1)\n        new_dir = os.path.abspath(os.path.join(self.current_dir, path))\n        if self.is_safe_path(new_dir):\n            os.chdir(new_dir)\n            self.current_dir = new_dir\n            print_info(f"Changed directory to: {self.current_dir}")\n            return f"Changed directory to: {self.current_dir}"\n        else:\n            print_error(f"Cannot change to directory: {new_dir}")\n            return f"Failed to change directory to: {new_dir}"\n\n    def reset_directory(self):\n        os.chdir(self.initial_dir)\n        project_dir = self.current_dir\n        self.current_dir = self.initial_dir\n        print_info(\n            f"Resetting directory to: {self.current_dir} from project dir:{project_dir}")