import unittest\\nfrom unittest.mock import patch, MagicMock\\nimport os\\nimport json\\n\\nclass TestFileOperations(unittest.TestCase):\\n\\n    @patch('os.path.exists', return_value=True)\\n    @patch('builtins.open', new_callable=mock_open, read_data='existing content')\n    def test_perform_file_operation_create(self, mock_file, mock_exists):\\n        executor = Executor()\\n        result = executor.perform_file_operation('CREATE', 'test.txt', 'content')\\n        self.assertTrue(result)\\n        mock_file.assert_called_with(os.path.join(executor.current_dir, 'test.txt'), 'w')\\n        mock_file().write.assert_called_with('content')\\n\\n    @patch('os.path.exists', return_value=True)\\n    @patch('os.path.isfile', return_value=True)\\n    @patch('os.remove')\\n    def test_perform_file_operation_delete(self, mock_remove, mock_isfile, mock_exists):\\n        executor = Executor()\\n        result = executor.perform_file_operation('DELETE', 'test.txt')\\n        self.assertTrue(result)\\n        mock_remove.assert_called_with(os.path.join(executor.current_dir, 'test.txt'))\\n\\n    def test_parse_json(self):\\n        valid_json = '{\\"key\\": \\\"value\\"}'\\n        invalid_json = '{key: value}'\\n        executor = Executor()\\n        self.assertEqual(executor.parse_json(valid_json), {'key': 'value'})\\n        self.assertIsNone(executor.parse_json(invalid_json))\\n\\n    def test_merge_json(self):\\n        existing_content = '{\\"key1\\": \\\"value1\\"}'\\n        new_content = '{\\"key2\\": \\\"value2\\"}'\\n        executor = Executor()\\n        expected_result = json.dumps({\\"key1\\": \\\"value1\\"\\,\\"key2\\": \\\"value2\\"\\}, indent=2)\\n        self.assertEqual(executor.merge_json(existing_content, new_content), expected_result)\\n\\nif __name__ == '___main___':\\n    unittest.main()