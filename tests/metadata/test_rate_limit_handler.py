import unittest\nfrom unittest.mock import patch, MagicMock\nimport asyncio\nimport time\nimport xml.etree.ElementTree as ET\n\nfrom drd.metadata.rate_limit_handler import (\n    RateLimiter, \n    process_single_file, \n    process_files, \n    MAX_CONCURRENT_REQUESTS, \n    MAX_CALLS_PER_MINUTE, \n    RATE_LIMIT_PERIOD \n)\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\nclass TestRateLimitHandler(unittest.IsolatedAsyncioTestCase):\n\n    async def test_rate_limiter(self):\n        limiter = RateLimiter(3, 1) \n        start_time = time.time()\n\n        acquire_times = []\n        for i in range(5):\n            await limiter.acquire()\n            current_time = time.time()\n            acquire_times.append(current_time - start_time)\n            logger.debug(f"Acquire {i+1} at {current_time - start_time:.4f} seconds")\n\n        end_time = time.time()\n        total_time = end_time - start_time\n\n        logger.debug(f"Total time: {total_time:.4f} seconds")\n        logger.debug(f"Acquire times: {acquire_times}")\n\n        self.assertLess(acquire_times[2] - acquire_times[0], 0.1)\n        self.assertGreater(acquire_times[3] - acquire_times[2], 0.9)\n        self.assertGreater(total_time, 0.9)\n\n    @patch('drd.metadata.rate_limit_handler.call_dravid_api_with_pagination')\n    @patch('drd.metadata.rate_limit_handler.extract_and_parse_xml')\n    async def test_process_single_file(self, mock_extract_xml, mock_call_api):\n        mock_call_api.return_value = "<response><type>python</type><description>A test file</description><exports>test_function</exports></response>"\n        mock_root = ET.fromstring(mock_call_api.return_value)\n        mock_extract_xml.return_value = mock_root\n\n        result = await process_single_file("test.py", "print('Hello')", "Test project", {"test.py": "file"})\n\n        self.assertEqual(result, ("test.py", "python", \n                         "A test file", "test_function", ""))\n        mock_call_api.assert_called_once()\n        mock_extract_xml.assert_called_once_with(mock_call_api.return_value)\n\n    @patch('drd.metadata.rate_limit_handler.call_dravid_api_with_pagination')\n    @patch('drd.metadata.rate_limit_handler.extract_and_parse_xml')\n    async def test_process_single_file_error(self, mock_extract_xml, mock_call_api):\n        mock_call_api.side_effect = Exception("API Error")\n\n        result = await process_single_file("test.py", "print('Hello')", "Test project", {"test.py": "file"})\n\n        self.assertEqual(result[0], "test.py")\n        self.assertEqual(result[1], "unknown")\n        self.assertTrue(result[2].startswith("Error:"))\n        self.assertEqual(result[3], "")\n\n    @patch('drd.metadata.rate_limit_handler.process_single_file')\n    async def test_process_files(self, mock_process_single_file):\n        mock_process_single_file.side_effect = [\n            ("file1.py", "python", "File 1", "func1", ""),\n            ("file2.py", "python", "File 2", "func2", "") \n        ]\n\n        files = [("file1.py", "content1"), ("file2.py", "content2")]\n        project_context = "Test project"\n        folder_structure = {"file1.py": "file", "file2.py": "file"}\n\n        results = await process_files(files, project_context, folder_structure)\n\n        self.assertEqual(len(results), 2)\n        self.assertEqual(results[0], ("file1.py", "python", "File 1", "func1", ""))\n        self.assertEqual(results[1], ("file2.py", "python", "File 2", "func2", ""))\n\n    @patch('drd.metadata.rate_limit_handler.process_single_file')\n    async def test_process_files_concurrency(self, mock_process_single_file):\n        async def slow_process(*args):\n            await asyncio.sleep(0.1)\n            return ("file.py", "python", "Slow file", "func", "")\n\n        mock_process_single_file.side_effect = slow_process\n\n        files = [("file.py", "content")] * 20 \n        project_context = "Test project"\n        folder_structure = {"file.py": "file"}\n\n        start_time = time.time()\n        await process_files(files, project_context, folder_structure)\n        end_time = time.time()\n\n        self.assertLess(end_time - start_time, 0.3)\n