import unittest\\\nfrom unittest.mock import patch, mock_open, MagicMock\\\\\nimport os\\\\\nimport json\\\\\nimport subprocess\\\\nfrom io import StringIO\\\\n\\\n# Update this import to match your actual module structure\\\\\nfrom drd.utils.step_executor import Executor\\\\nfrom drd.utils.apply_file_changes import apply_changes\\\\n\\\nclass TestExecutor(unittest.TestCase):\\\\\n\\\n    def setUp(self):\\\\\n        self.executor = Executor()\\\\\n        self.executor.initial_dir = os.getcwd()  # Initialize with a specific directory\\\\\n\\\n    def test_is_safe_path(self):\\\\\n        self.assertTrue(self.executor.is_safe_path('test.txt'))\\\\\n        self.assertFalse(self.executor.is_safe_path('/etc/passwd'))\\\\\n\\\n    def test_is_safe_rm_command(self):\\\\\n        # Assuming 'rm test.txt' is not considered safe without additional checks\\\\\n        self.assertFalse(self.executor.is_safe_rm_command('rm test.txt'))\\\\\n        # Test with a file that exists in the current directory\\\\\n        with patch('os.path.isfile', return_value=True):\\\\\n            self.assertTrue(self.executor.is_safe_rm_command('rm existing_file.txt'))\\\\\n        self.assertFalse(self.executor.is_safe_rm_command('rm -rf /'))\\\\\n        self.assertFalse(self.executor.is_safe_rm_command('rm -f test.txt'))\\\\\n\\\n    def test_is_safe_command(self):\\\\\n        self.assertTrue(self.executor.is_safe_command('ls'))\\\\\n        self.assertFalse(self.executor.is_safe_command('sudo rm -rf /'))\\\\\n\\\n    @patch('os.path.exists')\\\\\n    @patch('builtins.open', new_callable=mock_open)\\\\n    def test_perform_file_operation_create(self, mock_file, mock_exists):\\\\n        mock_exists.return_value = False\\\\n        result = self.executor.perform_file_operation('CREATE', 'test.txt', 'content')\\\\n        self.assertTrue(result)\\\\n        mock_file.assert_called_with(os.path.join(self.executor.current_dir, 'test.txt'), 'w')\\\\n        mock_file().write.assert_called_with('content')\\\\n\\\n    @patch('os.path.exists')\\\\\n    @patch('os.path.isfile')\\\\\n    @patch('os.remove')\\\\\n    def test_perform_file_operation_delete(self, mock_remove, mock_isfile, mock_exists):\\\\n        mock_exists.return_value = True\\\\n        mock_isfile.return_value = True\\\\n        result = self.executor.perform_file_operation('DELETE', 'test.txt')\\\\n        self.assertTrue(result)\\\\n        mock_remove.assert_called_with(os.path.join(self.executor.current_dir, 'test.txt'))\\\\n\\\n    def test_parse_json(self):\\\\\n        valid_json = '{\"key\": \"value\"}'\\\\\n        invalid_json = '{key: value}'\\\\\n        self.assertEqual(self.executor.parse_json(valid_json), {\"key\": \"value\"})\\\\\n        self.assertIsNone(self.executor.parse_json(invalid_json))\\\\\n\\\n    def test_merge_json(self):\\\\\n        existing_content = '{\"key1\": \"value1\"}'\\\\\n        new_content = '{\"key2\": \"value2\"}'\\\\\n        expected_result = json.dumps({\"key1\": \"value1\", \"key2\": \"value2\"}, indent=2)\\\\\n        self.assertEqual(self.executor.merge_json(existing_content, new_content), expected_result)\\\\\n\\\n    @patch('drd.utils.step_executor.get_ignore_patterns')\\\\\n    @patch('drd.utils.step_executor.get_folder_structure')\\\\\n    def test_get_folder_structure(self, mock_get_folder_structure, mock_get_ignore_patterns):\\\\\n        mock_get_ignore_patterns.return_value = ([], None)\\\\\n        mock_get_folder_structure.return_value = {\"folder\": {\"file.txt\": \"file\"}}\\\\\n        result = self.executor.get_folder_structure()\\\\\n        self.assertEqual(result, {\"folder\": {\"file.txt\": \"file\"}})\\\\\n\\\n    @patch('subprocess.Popen')\\\\\n    def test_execute_shell_command(self, mock_popen):\\\\\n        mock_process = MagicMock()\\\\\n        mock_process.poll.side_effect = [None, 0]\\\\\n        mock_process.stdout.readline.return_value = 'output line'\\\\\n        mock_process.communicate.return_value = ('', '')\\\\\n        mock_popen.return_value = mock_process\\\\\n\\\n        result = self.executor.execute_shell_command('ls')\\\\\n        self.assertEqual(result, 'output line')\\\\\n\\\n    @patch('subprocess.run')\\\\\n    def test_handle_source_command(self, mock_run):\\\\\n        mock_run.return_value = subprocess.CompletedProcess(args=['source', 'test.sh'], returncode=0, stdout='KEY=value\n', stderr='')\\\\\n        with patch('os.path.isfile', return_value=True):\\\\\n            result = self.executor._handle_source_command('source test.sh')\\\\\n        self.assertEqual(result, "Source command executed successfully")\\\\\n        self.assertEqual(self.executor.env['KEY'], 'value')\\\\\n\\\n    def test_update_env_from_command(self):\\\\\n        # Test simple assignment\\\\\n        self.executor._update_env_from_command('TEST_VAR=test_value')\\\\\n        self.assertEqual(self.executor.env['TEST_VAR'], 'test_value')\\\\\n\\\n        # Test export command\\\\\n        self.executor._update_env_from_command('export EXPORT_VAR=export_value')\\\\\n        self.assertEqual(self.executor.env['EXPORT_VAR'], 'export_value')\\\\\n\\\n        # Test set command\\\\\n        self.executor._update_env_from_command('set SET_VAR=set_value')\\\\\n        self.assertEqual(self.executor.env['SET_VAR'], 'set_value')\\\\\n\\\n        # Test with quotes\\\\\n        self.executor._update_env_from_command('QUOTE_VAR="quoted value"')\\\\\n        self.assertEqual(self.executor.env['QUOTE_VAR'], 'quoted value')\\\\\n\\\n        # Test export with quotes\\\\\n        self.executor._update_env_from_command('export EXPORT_QUOTE="exported quoted value"')\\\\\n        self.assertEqual(self.executor.env['EXPORT_QUOTE'], 'exported quoted value')\\\\\n\\\n    @patch('os.path.exists')\\\\\n    @patch('builtins.open', new_callable=mock_open)\\\\\n    @patch('click.confirm')\\\\\n    def test_perform_file_operation_create(self, mock_confirm, mock_file, mock_exists):\\\\\n        mock_exists.return_value = False\\\\\n        mock_confirm.return_value = True\\\\\n        result = self.executor.perform_file_operation('CREATE', 'test.txt', 'content')\\\\\n        self.assertTrue(result)\\\\\n        mock_file.assert_called_with(os.path.join(self.executor.current_dir, 'test.txt'), 'w')\\\\\n        mock_file().write.assert_called_with('content')\\\\\n        mock_confirm.assert_called_once()\\\\\n\\\n    @patch('os.path.exists')\\\\\n    @patch('builtins.open', new_callable=mock_open, read_data="original content")\\\\\n    @patch('click.confirm')\\\\\n    @patch('drd.utils.step_executor.preview_file_changes')\\\\\n    def test_perform_file_operation_update(self, mock_preview, mock_confirm, mock_file, mock_exists):\\\\\n        mock_exists.return_value = True\\\\\n        mock_confirm.return_value = True\\\\\n        mock_preview.return_value = "Preview of changes"\\\\\n\\\n        # Define the changes to be applied\\\\\n        changes = "+ 2: This is a new line\nr 1: This is a replaced line"\\\\\n\\\n        result = self.executor.perform_file_operation('UPDATE', 'test.txt', changes)\\\\\n\\\n        self.assertTrue(result)\\\\\n        mock_file.assert_any_call(os.path.join(self.executor.current_dir, 'test.txt'), 'r')\\\\\n        mock_file.assert_any_call(os.path.join(self.executor.current_dir, 'test.txt'), 'w')\\\\\n\\\n        # Calculate the expected updated content\\\\\n        expected_updated_content = apply_changes("original content", changes)\\\\\n\\\n        mock_preview.assert_called_once_with('UPDATE', 'test.txt', new_content=expected_updated_content, original_content="original content")\\\\\n        mock_file().write.assert_called_once_with(expected_updated_content)\\\\\n\\\n    @patch('os.path.exists')\\\\\n    @patch('os.path.isfile')\\\\\n    @patch('os.remove')\\\\\n    @patch('click.confirm')\\\\\n    def test_perform_file_operation_delete(self, mock_confirm, mock_remove, mock_isfile, mock_exists):\\\\\n        mock_exists.return_value = True\\\\\n        mock_isfile.return_value = True\\\\\n        mock_confirm.return_value = True\\\\\n        result = self.executor.perform_file_operation('DELETE', 'test.txt')\\\\\n        self.assertTrue(result)\\\\\n        mock_remove.assert_called_with(os.path.join(self.executor.current_dir, 'test.txt'))\\\\\n        mock_confirm.assert_called_once()\\\\\n\\\n    @patch('click.confirm')\\\\\n    def test_perform_file_operation_user_cancel(self, mock_confirm):\\\\\n        mock_confirm.return_value = False\\\\\n        result = self.executor.perform_file_operation('UPDATE', 'test.txt', 'content')\\\\\n        self.assertFalse(result)\\\\\n        mock_confirm.assert_called_once()\\\\\n\\\n    @patch('subprocess.Popen')\\\\\n    @patch('click.confirm')\\\\\n    def test_execute_shell_command(self, mock_confirm, mock_popen):\\\\\n        mock_confirm.return_value = True\\\\\n        mock_process = MagicMock()\\\\\n        mock_process.poll.side_effect = [None, 0]\\\\\n        mock_process.stdout.readline.return_value = 'output line'\\\\\n        mock_process.communicate.return_value = ('', '')\\\\\n        mock_popen.return_value = mock_process\\\\\n\\\n        result = self.executor.execute_shell_command('ls')\\\\\n        self.assertEqual(result, 'output line')\\\\\n        mock_confirm.assert_called_once()\\\\\n\\\n    @patch('click.confirm')\\\\\n    def test_execute_shell_command_user_cancel(self, mock_confirm):\\\\\n        mock_confirm.return_value = False\\\\\n        result = self.executor.execute_shell_command('ls')\\\\\n        mock_confirm.assert_called_once()\\\\\n